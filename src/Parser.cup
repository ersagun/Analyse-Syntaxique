package fr.ul.miage.analyse.generated;
import TDS.*;
import AST.*;

/*
 * analyseur syntaxique  du :
 * Projet interpreteur
 * 
 *
 * (c) 2014-2015
 * ---- Grammaire mini interpréteur
 */ 

action code {:

//TDS principale
TDS tds=new TDS();

//AST la racine 
NoeudElement ast=new NRacine();

//Compteur de SCOPE
int scope;

//Compteur de Rang
int rang;

//Compteur cpt_id
int cpt_tdsId=0;

//ValeurAttributDeclaration
int atomeGlob=0;

//Valeur affectation
int atome=0;

//Compteur parametre de fonction
int cpt_param=0;

//Compteur variable local ds fonction

int cpt_var_loc=0;

//le dernier id Fonct
int idFonct=-1;

//le dernier type de retour de fonction
String lastType="void";

//le dernier nom de fonction
String lfonctName="main";

//les instructions
NoeudElement instruction=null;
:}



parser code{:

public String afficheTDSetAST(){
String s="";
return "\n\n TDS :"+action_obj.tds.afficheTDS()+"\n\n -----------------------------\n\n AST:\n"+NoeudElement.afficheLesFils(action_obj.ast,action_obj.tds,s)+"\n";


}


public void afficheLastTDS(){
//System.out.println(action_obj.tds.afficheTDS());
}
:}


/* la grammaire */

terminal ADD, MUL, PO, PF, EGAL, PV, SUB, DIV, ACCO, ACCF, VIRG;
terminal Integer NUM;
terminal String IDF;
terminal String INT;
terminal String VOID;
terminal RETURN, WRITE, READ;
terminal  WHILE, IF, ELSE, BOOLEEN, NOT, OPERATEURCOMPARAISON;

non terminal NOperation expression; 
non terminal NOperation facteur;
non terminal Integer atome;
non terminal expressionGLOBALE, facteurGLOBALE;
non terminal Integer atomeGLOBALE;
non terminal NAffectation affectation;
non terminal NoeudElement instruction;
non terminal  ecriture;
non terminal NoeudElement listinstruction; 
non terminal listparametre;
non terminal  expressionbooleenne;
non terminal  conditionnelle, iteration;
non terminal  ensembledeclaration, suitedeclaration;
non terminal  appelfonction;


non terminal NFonction  fonction;
non terminal listcommande, commande;
non terminal Parametre listdeclarationparametre;
non terminal ensembledeclarationGLOBALE;
non terminal Variable suitedeclarationGLOBALE;

non terminal  programme;


programme       ::= listcommande
                    ;
          
listcommande    ::= commande listcommande
                  |
                  ;

commande ::=    fonction:f {:ast.ajouter1fils(((NFonction)f));:}
            |   ensembledeclarationGLOBALE
            ;

ensembledeclarationGLOBALE  ::=    INT:t IDF:i VIRG suitedeclarationGLOBALE:sdg PV 		{: tds.ajoute(new Variable(((Integer)cpt_tdsId), ((String)i), -1, 0, ((String)t)));
																						   cpt_tdsId++;
																						   sdg.setType(((String)t));
																						   tds.ajoute(((Variable)sdg));
																						:}
																						
																						
                              |    INT:t IDF:i PV {: tds.ajoute(new Variable(((Integer)cpt_tdsId), ((String)i), -1, 0, ((String)t)));
                              						 cpt_tdsId++; 
                              					  :}
                              
                              
                              |    INT:t IDF:i EGAL expressionGLOBALE:e PV {: tds.ajoute(new Variable(((Integer)cpt_tdsId), ((String)i), -1, atomeGlob, ((String)t)));
                              												  cpt_tdsId++; 
                              											   :}
                              ;
                              
                              

suitedeclarationGLOBALE   ::=   IDF:i VIRG suitedeclarationGLOBALE {: RESULT=new Variable(((Integer)cpt_tdsId), ((String)i), -1, 0,"undefined");
																	  cpt_tdsId++;
																   :}
																   
                            |   IDF:i EGAL expressionGLOBALE:e {:((Variable)tds.searchVariable(((String)i),-1)).setVal(((Integer)e)); 
                            								   :}
                            								   
                            |   IDF:i {:RESULT=new Variable(((Integer)cpt_tdsId), ((String)i), -1, 0,"undefined");
                            		   cpt_tdsId++;
                            		   :}
                            ;

expressionGLOBALE      ::=  expressionGLOBALE:e1  ADD facteurGLOBALE:e2  //dans les exemples les variables globales sont initializé
                        |   expressionGLOBALE:e1  SUB  facteurGLOBALE:e2 //dans les exemples les variables globales sont initializé
                        |   facteurGLOBALE:e 
                        ;

facteurGLOBALE         ::=  facteurGLOBALE:e1  MUL  atomeGLOBALE:e2 //dans les exemples les variables globales sont initializé
                        |   facteurGLOBALE:e1  DIV  atomeGLOBALE:e2 //dans les exemples les variables globales sont initializé
                        |   atomeGLOBALE:attommeglob {:atomeGlob=((int)attommeglob);:}
                        ;

atomeGLOBALE           ::=  NUM:e {:RESULT=new Integer(e);:}
                        |   IDF:e {:RESULT=new Integer(((Integer)((Variable)tds.searchVariable(((String)e),-1)).getVal()));:}
                        |   PO expressionGLOBALE:e PF
                        ;


fonction ::= INT:t  IDF:nomFonct  PO  listdeclarationparametre:p  PF  ACCO  listinstruction:l  ACCF{: if(p!=null){
																									 	((Parametre)p).setScope(cpt_tdsId);
																									 	tds.ajoute(p);
																									 }
																									 
																									 tds.ajoute(new Fonction(((Integer)cpt_tdsId), ((String)nomFonct), ((Integer)cpt_param), ((Integer)cpt_var_loc), ((String)t)));
																									 RESULT=new NFonction(((Integer)cpt_tdsId));
																									 cpt_tdsId++; 
																									 cpt_param=0;
																									 cpt_var_loc=0;
																									
																									 :}


          |  VOID:v IDF:nomFonct PO listdeclarationparametre:p PF ACCO listinstruction:l ACCF{:		 if(p!=null){
																									 	((Parametre)p).setScope(cpt_tdsId);
																									 	tds.ajoute(p);
																									 }
																									 
																									 tds.ajoute(new Fonction(((Integer)cpt_tdsId), ((String)nomFonct), ((Integer)cpt_param), ((Integer)cpt_var_loc), ((String)v)));
																									 NFonction fonct=new NFonction(((Integer)cpt_tdsId));
																									 fonct.ajouter1fils(l);
																									 RESULT=fonct;
																									 cpt_tdsId++; 
																									 cpt_param=0;
																									 cpt_var_loc=0;
																									 
																									 :}
          |  IDF:nomFonct PO listdeclarationparametre:p PF ACCO listinstruction:l ACCF{:					
          																							if(p!=null){
																									 	((Parametre)p).setScope(cpt_tdsId);
																									 	tds.ajoute(p);
																									 }
																									 tds.ajoute(new Fonction(((Integer)cpt_tdsId), ((String)nomFonct), ((Integer)cpt_param), ((Integer)cpt_var_loc), "void"));
																									 RESULT=new NFonction(((Integer)cpt_tdsId));
																									 cpt_tdsId++; 
																									 cpt_param=0;
																									 cpt_var_loc=0;
																									 
																									 :}
          ;

listdeclarationparametre ::= INT:t IDF:i VIRG listdeclarationparametre:p {:           RESULT=new Parametre(((Integer)cpt_tdsId), ((String)i), 00, cpt_param, ((String)t),0);
																							 cpt_tdsId++;
																						   cpt_param++; :}
																						   
                           |  INT:t IDF:i {:											   RESULT=new Parametre(((Integer)cpt_tdsId), ((String)i), 00, cpt_param, ((String)t),0);
																							 cpt_tdsId++;
																						   cpt_param++;:}
                           |  
                           ;

listinstruction ::= instruction:inst listinstruction:l{:RESULT=inst;:}
                 |  RETURN expression:e PV
                 |  
                 ;

instruction     ::= affectation:aff {:RESULT=aff;:}
                  | ecriture:ec
                  | ensembledeclaration:decl
                  | conditionnelle:cond
                  | iteration:it
                  | appelfonction:ap PV
                  ;

conditionnelle ::= IF PO expressionbooleenne:expBool PF ACCO listinstruction:l ACCF
                 | IF PO expressionbooleenne:expBool PF ACCO listinstruction:l1 ACCF ELSE ACCO listinstruction:l2 ACCF 
                  
                 ;

iteration ::= WHILE PO expressionbooleenne:expBool PF ACCO listinstruction:l ACCF
            ;


expressionbooleenne ::= expression:e1 OPERATEURCOMPARAISON:comp expression:e2
                      | NOT expressionbooleenne
                      | BOOLEEN:b
                      ;

ensembledeclaration  ::=    INT:t  IDF:i  VIRG suitedeclaration PV {:cpt_var_loc++;:}
                       |    INT:t IDF:i PV {:cpt_var_loc++;:}
                       ;

suitedeclaration ::=    IDF:i VIRG suitedeclaration {:cpt_var_loc++;:}
                    |   IDF:i EGAL expression:e
                    |   IDF:i {:cpt_var_loc++;:}
                    ;
            
affectation   ::=   IDF:i  EGAL expression:e PV {:


if(tds.searchVariable(((String)i)) instanceof Variable){
((Variable)tds.searchVariable(((String)i))).setVal(atome);
NAffectation a=new NAffectation(((String)i), ((Integer)((Variable)tds.searchVariable(((String)i))).getId()), "=", tds);
a.ajouterFD(e);
RESULT=a;
}
if(tds.searchVariable(((String)i)) instanceof Vlocale){
((Vlocale)tds.searchVariable(((String)i))).setVal(atome);
NAffectation a=new NAffectation(((String)i), ((Integer)((Vlocale)tds.searchVariable(((String)i))).getId()), "=", tds);
a.ajouterFD(e);
RESULT=a;
}
if(tds.searchVariable(((String)i)) instanceof Parametre){
((Parametre)tds.searchVariable(((String)i))).setVal(atome);
NAffectation a=new NAffectation(((String)i), ((Integer)((Parametre)tds.searchVariable(((String)i))).getId()), "=", tds);
a.ajouterFD(e);
RESULT=a;
}



:}
												 
               |    INT IDF:i  EGAL expression:e PV
                  ;

appelfonction ::=  IDF:nomFonct PO listparametre:l PF
                 | IDF:nomFonct PO PF
                  ;

listparametre ::=  expression:e VIRG listparametre:l
                |  expression:e  
                ;
          
ecriture        ::= WRITE PO expression:e PF PV
                ;

            
expression      ::= expression:e1  ADD facteur:e2
                  | expression:e1  SUB  facteur:e2 
                  | facteur:e {:
                  
                  RESULT=e;
                  :}
                  ;

facteur         ::= facteur:e1  MUL  atome:e2 
                  | facteur:e1  DIV  atome:e2
                  | atome:e {:RESULT=new NConstant(e);
                  				atome=((int)e);
                  :}
                  
                  | appelfonction:ap
                  ;

atome           ::= NUM:e {:RESULT=new Integer(e);:}
                  | IDF:e {:RESULT=new Integer(((Integer)((Variable)tds.search(((String)e))).getVal()));:}
                  | READ PO PF
                  | PO expression:e PF
                  ;